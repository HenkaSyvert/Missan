



Entity Component System:
- Components are stored per type in contigous arrays. 
- array elements are associative with an game object ID. 
- All instances of GameObject and Component are ALWAYS managed by the ECS. 
	- since users are never allowed to manage memory of GameObject or Component directly, 
	  they can ONLY be instantiated with GameObject::Instantiate() and GameObject::Add<Component>(). 
- because memory location of instantiated GameObjects and Components may change at end of frame, 
  because of deletion of other gameobjects/components, any pointer is only valid for 1 frame. 
	- therefore, users have instanceIDs to identity GameObjects and Components. 




memory:
	- creates contiguous arrays per type
	- access via GUID per instance. 
	- get/set individual element by ID, or whole type array for iteration. 
	- (in future, custom memory allocators because why not)
	- deals with both ASSETS and ECS things. 


ECS:
	- layer on top of memory
	- basically just maps a single game object ID to 1 or more component IDs. 
	- also handles calling of onDestroy, Start, etc 

flow for asset:
raw asset in folder --> generate internal format based on import --> actually load into game, in contiguous arr. 


Editor:
	AssetDatabase
	Editor
		CameraEditor
		AbcEditor
	EditorApplication
		stepSingleFrame()
		IsUpdating?
		isCompiling?
		funcDelegate<Update>
	ExpressionEvaluator
	EditorWindow : ScriptableObject
	FileUtil
	Importer
		for different file types
	unique ID per asset
	.meta file
		ID + import settings



editor:
	assetDatabase
	- original asset files are left intact. 
	- they are transformed into internal 
	  game-ready representation in separate
	  folder, according to import settings. 
	- 